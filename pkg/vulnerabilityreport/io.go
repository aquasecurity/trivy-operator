package vulnerabilityreport

import (
	"context"
	"time"

	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	tn "k8s.io/apimachinery/pkg/types"
	"k8s.io/utils/ptr"
	"sigs.k8s.io/controller-runtime/pkg/client"

	"github.com/aquasecurity/trivy-db/pkg/types"
	"github.com/aquasecurity/trivy-operator/pkg/apis/aquasecurity/shared"
	"github.com/aquasecurity/trivy-operator/pkg/apis/aquasecurity/v1beta1"
	"github.com/aquasecurity/trivy-operator/pkg/ext"
	"github.com/aquasecurity/trivy-operator/pkg/kube"
	ty "github.com/aquasecurity/trivy/pkg/types"
)

// Writer is the interface that wraps the basic Write method.
//
// Write creates or updates the given slice of v1beta1.VulnerabilityReport
// instances.
type Writer interface {
	Write(context.Context, []v1beta1.VulnerabilityReport) error
	WriteCluster(context.Context, []v1beta1.ClusterVulnerabilityReport) error
}

// Reader is the interface that wraps methods for finding v1beta1.VulnerabilityReport objects.
//
// FindByOwner returns the slice of v1beta1.VulnerabilityReport instances
// owned by the given kube.ObjectRef or an empty slice if the reports are not found.
type Reader interface {
	FindByOwner(context.Context, kube.ObjectRef) ([]v1beta1.VulnerabilityReport, error)
}

type ReadWriter interface {
	Reader
	Writer
}

type readWriter struct {
	*kube.ObjectResolver
}

// NewReadWriter constructs a new ReadWriter which is using the client package
// provided by the controller-runtime libraries for interacting with the
// Kubernetes API server.
func NewReadWriter(objectResolver *kube.ObjectResolver) ReadWriter {
	return &readWriter{
		ObjectResolver: objectResolver,
	}
}

func (r *readWriter) Write(ctx context.Context, reports []v1beta1.VulnerabilityReport) error {
	for _, report := range reports {
		err := r.createOrUpdate(ctx, report)
		if err != nil {
			return err
		}
	}
	return nil
}

func (r *readWriter) WriteCluster(ctx context.Context, reports []v1beta1.ClusterVulnerabilityReport) error {
	for _, report := range reports {
		err := r.createOrUpdateCluster(ctx, report)
		if err != nil {
			return err
		}
	}
	return nil
}

func (r *readWriter) createOrUpdate(ctx context.Context, report v1beta1.VulnerabilityReport) error {
	var existing v1beta1.VulnerabilityReport
	err := r.Get(ctx, tn.NamespacedName{
		Name:      report.Name,
		Namespace: report.Namespace,
	}, &existing)

	if err == nil {
		copied := existing.DeepCopy()
		copied.Labels = report.Labels
		copied.Report = report.Report

		return r.Update(ctx, copied)
	}

	if errors.IsNotFound(err) {
		return r.Create(ctx, &report)
	}

	return err
}

func (r *readWriter) createOrUpdateCluster(ctx context.Context, report v1beta1.ClusterVulnerabilityReport) error {
	var existing v1beta1.ClusterVulnerabilityReport
	err := r.Get(ctx, tn.NamespacedName{
		Name: report.Name,
	}, &existing)

	if err == nil {
		copied := existing.DeepCopy()
		copied.Labels = report.Labels
		copied.Report = report.Report

		return r.Update(ctx, copied)
	}

	if errors.IsNotFound(err) {
		return r.Create(ctx, &report)
	}

	return err
}

func (r *readWriter) FindByOwner(ctx context.Context, owner kube.ObjectRef) ([]v1beta1.VulnerabilityReport, error) {
	var list v1beta1.VulnerabilityReportList

	labels := client.MatchingLabels(kube.ObjectRefToLabels(owner))

	err := r.List(ctx, &list, labels, client.InNamespace(owner.Namespace))
	if err != nil {
		return nil, err
	}

	return list.DeepCopy().Items, nil
}

type AdditionalFields struct {
	Resource         bool
	InstalledVersion bool
	FixedVersion     bool
	PublishedDate    bool
	LastModifiedDate bool
	Title            bool
	PrimaryLink      bool
	Score            bool
	PkgPURL          bool
	Description      bool
	Links            bool
	CVSS             bool
	Target           bool
	Class            bool
	PackageType      bool
	PkgPath          bool
}

func NewDefaultAdditionalFields() AdditionalFields {
	return AdditionalFields{
		Resource:         true,
		InstalledVersion: true,
		FixedVersion:     true,
		PublishedDate:    true,
		LastModifiedDate: true,
		Title:            true,
		PrimaryLink:      true,
		Score:            true,
		PkgPURL:          true,
	}
}

func GetVulnerabilitiesFromScanResult(report ty.Result, addFields AdditionalFields) []v1beta1.Vulnerability {
	vulnerabilities := make([]v1beta1.Vulnerability, 0)

	for _, sr := range report.Vulnerabilities {
		vulnerability := v1beta1.Vulnerability{
			VulnerabilityID: sr.VulnerabilityID,
			Severity:        shared.Severity(sr.Severity),
		}

		if addFields.Resource {
			vulnerability.Resource = sr.PkgName
		}
		if addFields.InstalledVersion {
			vulnerability.InstalledVersion = sr.InstalledVersion
		}
		if addFields.FixedVersion {
			vulnerability.FixedVersion = sr.FixedVersion
		}
		if addFields.PublishedDate && sr.PublishedDate != nil {
			vulnerability.PublishedDate = sr.PublishedDate.Format(time.RFC3339)
		}
		if addFields.LastModifiedDate && sr.LastModifiedDate != nil {
			vulnerability.LastModifiedDate = sr.LastModifiedDate.Format(time.RFC3339)
		}
		if addFields.Title {
			vulnerability.Title = sr.Title
		}
		if addFields.PrimaryLink {
			vulnerability.PrimaryLink = sr.PrimaryURL
		}
		if addFields.Score {
			vulnerability.Score = GetScoreFromCVSS(GetCvssV3(sr.CVSS))
		}
		if addFields.PkgPURL && sr.PkgIdentifier.PURL != nil {
			vulnerability.PkgPURL = sr.PkgIdentifier.PURL.String()
		}

		if addFields.Description {
			vulnerability.Description = sr.Description
		}
		if addFields.Links && sr.References != nil {
			vulnerability.Links = sr.References
		}
		if addFields.CVSS {
			vulnerability.CVSS = sr.CVSS
		}
		if addFields.Target {
			vulnerability.Target = report.Target
		}
		if addFields.Class {
			vulnerability.Class = string(report.Class)
		}
		if addFields.PackageType {
			vulnerability.PackageType = string(report.Type)
		}
		if addFields.PkgPath {
			vulnerability.PkgPath = sr.PkgPath
		}

		vulnerabilities = append(vulnerabilities, vulnerability)
	}

	return vulnerabilities
}

func GetCvssV3(findingCvss types.VendorCVSS) map[string]*CVSS {
	cvssV3 := make(map[string]*CVSS)
	for vendor, cvss := range findingCvss {
		var v3Score *float64
		if cvss.V3Score != 0.0 {
			v3Score = ptr.To[float64](cvss.V3Score)
		}
		cvssV3[string(vendor)] = &CVSS{v3Score}
	}
	return cvssV3
}

func GetScoreFromCVSS(cvsss map[string]*CVSS) *float64 {
	var nvdScore, vendorScore *float64

	for name, cvss := range cvsss {
		if name == "nvd" {
			nvdScore = cvss.V3Score
		} else {
			vendorScore = cvss.V3Score
		}
	}

	if vendorScore != nil {
		return vendorScore
	}

	return nvdScore
}

type CVSS struct {
	V3Score *float64 `json:"V3Score,omitempty"`
}

func BuildVulnerabilityReportData(clock ext.Clock, registry shared.Registry, artifact shared.Artifact, os shared.OS, version string, vulnerabilities []v1beta1.Vulnerability) v1beta1.VulnerabilityReportData {
	return v1beta1.VulnerabilityReportData{
		UpdateTimestamp: metav1.NewTime(clock.Now()),
		Scanner: shared.Scanner{
			Name:    shared.ScannerNameTrivy,
			Vendor:  "Aqua Security",
			Version: version,
		},
		Registry:        registry,
		Artifact:        artifact,
		OS:              os,
		Summary:         vulnerabilitySummary(vulnerabilities),
		Vulnerabilities: vulnerabilities,
	}
}

func vulnerabilitySummary(vulnerabilities []v1beta1.Vulnerability) shared.VulnerabilitySummary {
	var vs shared.VulnerabilitySummary
	for _, v := range vulnerabilities {
		switch v.Severity {
		case shared.SeverityCritical:
			vs.CriticalCount++
		case shared.SeverityHigh:
			vs.HighCount++
		case shared.SeverityMedium:
			vs.MediumCount++
		case shared.SeverityLow:
			vs.LowCount++
		default:
			vs.UnknownCount++
		}
	}
	return vs
}
