package controller

import (
	"context"
	"reflect"

	"github.com/aquasecurity/trivy-operator/pkg/exposedsecretreport"
	"github.com/aquasecurity/trivy-operator/pkg/kube"
	"github.com/aquasecurity/trivy-operator/pkg/trivyoperator"
	"github.com/aquasecurity/trivy-operator/pkg/vulnerabilityreport"
)

func hasReports(ctx context.Context, esReadWriter exposedsecretreport.ReadWriter, vulnReadWriter vulnerabilityreport.ReadWriter, owner kube.ObjectRef, hash string, images kube.ContainerImages) (bool, error) {
	hasVulnerabilityReports, err := hasVulnerabilityReports(ctx, vulnReadWriter, owner, hash, images)
	if err != nil {
		return false, err
	}

	hasSecretReports, err := hasSecretReports(ctx, esReadWriter, owner, hash, images)
	if err != nil {
		return false, err
	}

	return hasVulnerabilityReports && hasSecretReports, nil
}

func hasVulnerabilityReports(ctx context.Context, vulnReadWriter vulnerabilityreport.ReadWriter, owner kube.ObjectRef, hash string, images kube.ContainerImages) (bool, error) {
	// TODO FindByOwner should accept optional label selector to further narrow down search results
	list, err := vulnReadWriter.FindByOwner(ctx, owner)
	if err != nil {
		return false, err
	}

	actual := map[string]bool{}
	for _, report := range list {
		if containerName, ok := report.Labels[trivyoperator.LabelContainerName]; ok {
			if hash == report.Labels[trivyoperator.LabelResourceSpecHash] {
				actual[containerName] = true
			}
		}
	}

	return compareReports(actual, images), nil
}

func hasSecretReports(ctx context.Context, esReadWriter exposedsecretreport.ReadWriter, owner kube.ObjectRef, hash string, images kube.ContainerImages) (bool, error) {
	// TODO FindByOwner should accept optional label selector to further narrow down search results
	list, err := esReadWriter.FindByOwner(ctx, owner)
	if err != nil {
		return false, err
	}

	actual := map[string]bool{}
	for _, report := range list {
		if containerName, ok := report.Labels[trivyoperator.LabelContainerName]; ok {
			if hash == report.Labels[trivyoperator.LabelResourceSpecHash] {
				actual[containerName] = true
			}
		}
	}

	return compareReports(actual, images), nil
}

func compareReports(actual map[string]bool, images kube.ContainerImages) bool {
	expected := map[string]bool{}
	for containerName := range images {
		expected[containerName] = true
	}

	return reflect.DeepEqual(actual, expected)
}
