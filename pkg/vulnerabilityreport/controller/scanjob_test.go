package controller

import (
	"context"
	"testing"

	"github.com/stretchr/testify/require"
	appsv1 "k8s.io/api/apps/v1"
	batchv1 "k8s.io/api/batch/v1"
	corev1 "k8s.io/api/core/v1"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/client/fake"
	"sigs.k8s.io/controller-runtime/pkg/log"

	v1alpha1 "github.com/aquasecurity/trivy-operator/pkg/apis/aquasecurity/v1alpha1"
	"github.com/aquasecurity/trivy-operator/pkg/kube"
	"github.com/aquasecurity/trivy-operator/pkg/operator/etc"
	"github.com/aquasecurity/trivy-operator/pkg/trivyoperator"
	"github.com/aquasecurity/trivy-operator/pkg/vulnerabilityreport"
)

// Function for creating all the required objects required for the tests to succeed
func setupTestEnvironment(testid string) (*ScanJobController, *batchv1.Job, error) {

	config, _ := etc.GetOperatorConfig()
	config.ExposedSecretScannerEnabled = false
	logger := log.Log.WithName("test-deletion-of-completed-scan-jobs")
	scannedResourceName := "scan-job-ttl-test-replicaset-" + testid
	namespace := "default"
	containerName := "scanner"

	// Create the replica set that was scanned
	replicaSet := &appsv1.ReplicaSet{
		ObjectMeta: metav1.ObjectMeta{
			Name:      scannedResourceName,
			Namespace: namespace,
		},
	}

	// Create the vulnerability report for the scanned replica set with the appropriate labels
	vulnReport := v1alpha1.VulnerabilityReport{
		TypeMeta: metav1.TypeMeta{
			APIVersion: v1alpha1.SchemeGroupVersion.String(),
			Kind:       "Job",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name:      "scan-job-ttl-test-vuln-report" + testid,
			Namespace: namespace,
			Labels: map[string]string{
				trivyoperator.LabelResourceKind:      "ReplicaSet",
				trivyoperator.LabelResourceNamespace: namespace,
				trivyoperator.LabelResourceName:      scannedResourceName,
				trivyoperator.LabelContainerName:     containerName,
				trivyoperator.LabelResourceSpecHash:  "hash",
			},
		},
	}

	containerImages := kube.ContainerImages{
		"scanner": "trivy:latest",
	}
	containerImagesAsJob, _ := containerImages.AsJSON()

	// Create the job that scanned the replica set. Needs to be in state completed
	job := &batchv1.Job{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "scan-job",
			Namespace: namespace,
			Labels: map[string]string{
				trivyoperator.LabelResourceSpecHash:  "hash",
				trivyoperator.LabelResourceKind:      "ReplicaSet",
				trivyoperator.LabelResourceNamespace: namespace,
				trivyoperator.LabelResourceName:      scannedResourceName,
			},
			Annotations: map[string]string{
				trivyoperator.AnnotationContainerImages: containerImagesAsJob,
			},
		},
		Spec: batchv1.JobSpec{
			Template: corev1.PodTemplateSpec{
				Spec: corev1.PodSpec{
					Containers: []corev1.Container{
						{
							Name:  containerName,
							Image: "trivy:latest",
						},
					},
					RestartPolicy: corev1.RestartPolicyNever,
				},
			},
		},
		Status: batchv1.JobStatus{
			Conditions: []batchv1.JobCondition{
				{
					Type: batchv1.JobComplete,
				},
			},
		},
	}

	client := fake.NewClientBuilder().WithScheme(trivyoperator.NewScheme()).WithObjects(job, replicaSet, &vulnReport).Build()
	objectResolver := kube.NewObjectResolver(client, nil)
	instance := &ScanJobController{
		Logger:                  logger,
		Config:                  config,
		VulnerabilityReadWriter: vulnerabilityreport.NewReadWriter(&objectResolver),
	}
	instance.Client = client

	return instance, job, nil
}

func TestDeletionOfCompletedScanJobs(t *testing.T) {
	tests := []struct {
		testId             string // Used to differentiate between tests
		name               string // Name of the test
		scannerJobTTL      int32  // TTL for the actual job that does the scanning
		wantScanJobDeleted bool   // true if the job should have been deleted after completion
	}{
		{
			testId:             "1",
			name:               "Job immediately deleted when ScannerReportTTL is empty",
			scannerJobTTL:      0,
			wantScanJobDeleted: true,
		},
		{
			testId:             "2",
			name:               "Job not deleted when ScannerReportTTL has been set",
			scannerJobTTL:      120,
			wantScanJobDeleted: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			instance, job, err := setupTestEnvironment(tt.testId)
			require.NoError(t, err)

			// Set the ttl for the cronjob itself if required by the test spec
			if tt.scannerJobTTL > 0 {
				job.Spec.TTLSecondsAfterFinished = &tt.scannerJobTTL
			}

			err = instance.processCompleteScanJob(context.TODO(), job, "scanner")
			require.NoError(t, err)

			// Fetch the job
			jobAfterCompletion := &batchv1.Job{}
			err = instance.Client.Get(context.TODO(), types.NamespacedName{Name: job.Name, Namespace: job.Namespace}, jobAfterCompletion)

			// If the test spec requires the job to be deleted, check that it has been indeed deleted
			if tt.wantScanJobDeleted {
				require.Error(t, err)
				require.True(t, apierrors.IsNotFound(err))
				return
			} else {
				require.NoError(t, err)
				require.NotNil(t, jobAfterCompletion)
			}
		})
	}
}
