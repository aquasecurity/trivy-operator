package controller

import (
	"context"
	"reflect"

	"github.com/aquasecurity/trivy-operator/pkg/apis/aquasecurity/v1alpha1"
	"github.com/aquasecurity/trivy-operator/pkg/exposedsecretreport"
	"github.com/aquasecurity/trivy-operator/pkg/kube"
	"github.com/aquasecurity/trivy-operator/pkg/sbomreport"
	"github.com/aquasecurity/trivy-operator/pkg/trivyoperator"
	"github.com/aquasecurity/trivy-operator/pkg/vulnerabilityreport"
)

func hasVulnerabilityReports(ctx context.Context, vulnReadWriter vulnerabilityreport.ReadWriter, owner kube.ObjectRef, hash string, images kube.ContainerImages) (bool, error) {
	// TODO FindByOwner should accept optional label selector to further narrow down search results
	list, err := vulnReadWriter.FindByOwner(ctx, owner)
	if err != nil {
		return false, err
	}

	actual := map[string]bool{}
	for _, report := range list {
		if containerName, ok := report.Labels[trivyoperator.LabelContainerName]; ok {
			if hash == report.Labels[trivyoperator.LabelResourceSpecHash] {
				actual[containerName] = true
			}
		}
	}

	return compareReports(actual, images), nil
}

func hasSecretReports(ctx context.Context, esReadWriter exposedsecretreport.ReadWriter, owner kube.ObjectRef, hash string, images kube.ContainerImages) (bool, error) {
	// TODO FindByOwner should accept optional label selector to further narrow down search results
	list, err := esReadWriter.FindByOwner(ctx, owner)
	if err != nil {
		return false, err
	}

	actual := map[string]bool{}
	for _, report := range list {
		if containerName, ok := report.Labels[trivyoperator.LabelContainerName]; ok {
			if hash == report.Labels[trivyoperator.LabelResourceSpecHash] {
				actual[containerName] = true
			}
		}
	}

	return compareReports(actual, images), nil
}

func compareReports(actual map[string]bool, images kube.ContainerImages) bool {
	expected := map[string]bool{}
	for containerName := range images {
		expected[containerName] = true
	}

	return reflect.DeepEqual(actual, expected)
}

func getGlobalSbomReports(ctx context.Context, sbomReadWriter sbomreport.ReadWriter, images kube.ContainerImages) (map[string]v1alpha1.SbomReportData, error) {
	sbomReportDataMap := make(map[string]v1alpha1.SbomReportData, 0)
	for name, ref := range images {
		list, err := sbomReadWriter.FindReportByImageRef(ctx, ref)
		if err != nil {
			return nil, err
		}

		if len(list) > 0 {
			for _, data := range list {
				sbomReportDataMap[name] = data.Report
			}
		}
	}
	return sbomReportDataMap, nil
}
