package vulnerabilityreport

import (
	"context"
	"time"

	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	tn "k8s.io/apimachinery/pkg/types"
	"k8s.io/utils/ptr"
	"sigs.k8s.io/controller-runtime/pkg/client"

	"github.com/aquasecurity/trivy-db/pkg/types"
	"github.com/aquasecurity/trivy-operator/pkg/apis/aquasecurity/v1alpha1"
	"github.com/aquasecurity/trivy-operator/pkg/ext"
	"github.com/aquasecurity/trivy-operator/pkg/kube"
	ty "github.com/aquasecurity/trivy/pkg/types"
)

// Writer is the interface that wraps the basic Write method.
//
// Write creates or updates the given slice of v1alpha1.VulnerabilityReport
// instances.
type Writer interface {
	Write(context.Context, []v1alpha1.VulnerabilityReport) error
	WriteCluster(context.Context, []v1alpha1.ClusterVulnerabilityReport) error
}

// Reader is the interface that wraps methods for finding v1alpha1.VulnerabilityReport objects.
//
// FindByOwner returns the slice of v1alpha1.VulnerabilityReport instances
// owned by the given kube.ObjectRef or an empty slice if the reports are not found.
type Reader interface {
	FindByOwner(context.Context, kube.ObjectRef) ([]v1alpha1.VulnerabilityReport, error)
}

type ReadWriter interface {
	Reader
	Writer
}

type readWriter struct {
	*kube.ObjectResolver
}

// NewReadWriter constructs a new ReadWriter which is using the client package
// provided by the controller-runtime libraries for interacting with the
// Kubernetes API server.
func NewReadWriter(objectResolver *kube.ObjectResolver) ReadWriter {
	return &readWriter{
		ObjectResolver: objectResolver,
	}
}

func (r *readWriter) Write(ctx context.Context, reports []v1alpha1.VulnerabilityReport) error {
	for _, report := range reports {
		err := r.createOrUpdate(ctx, report)
		if err != nil {
			return err
		}
	}
	return nil
}

func (r *readWriter) WriteCluster(ctx context.Context, reports []v1alpha1.ClusterVulnerabilityReport) error {
	for _, report := range reports {
		err := r.createOrUpdateCluster(ctx, report)
		if err != nil {
			return err
		}
	}
	return nil
}

func (r *readWriter) createOrUpdate(ctx context.Context, report v1alpha1.VulnerabilityReport) error {
	var existing v1alpha1.VulnerabilityReport
	err := r.Get(ctx, tn.NamespacedName{
		Name:      report.Name,
		Namespace: report.Namespace,
	}, &existing)

	if err == nil {
		copied := existing.DeepCopy()
		copied.Labels = report.Labels
		copied.Report = report.Report

		return r.Update(ctx, copied)
	}

	if errors.IsNotFound(err) {
		return r.Create(ctx, &report)
	}

	return err
}

func (r *readWriter) createOrUpdateCluster(ctx context.Context, report v1alpha1.ClusterVulnerabilityReport) error {
	var existing v1alpha1.ClusterVulnerabilityReport
	err := r.Get(ctx, tn.NamespacedName{
		Name: report.Name,
	}, &existing)

	if err == nil {
		copied := existing.DeepCopy()
		copied.Labels = report.Labels
		copied.Report = report.Report

		return r.Update(ctx, copied)
	}

	if errors.IsNotFound(err) {
		return r.Create(ctx, &report)
	}

	return err
}

func (r *readWriter) FindByOwner(ctx context.Context, owner kube.ObjectRef) ([]v1alpha1.VulnerabilityReport, error) {
	var list v1alpha1.VulnerabilityReportList

	labels := client.MatchingLabels(kube.ObjectRefToLabels(owner))

	err := r.List(ctx, &list, labels, client.InNamespace(owner.Namespace))
	if err != nil {
		return nil, err
	}

	return list.DeepCopy().Items, nil
}

type AdditionalFields struct {
	Description    bool
	Links          bool
	CVSS           bool
	Target         bool
	Class          bool
	PackageType    bool
	PkgPath        bool
	SeveritySource bool
	DataSource     bool
}

func GetVulnerabilitiesFromScanResult(report ty.Result, addFields AdditionalFields) []v1alpha1.Vulnerability {
	vulnerabilities := make([]v1alpha1.Vulnerability, 0)
	// match Trivy preferred sources (this may change in the future)
	preferredSources := []string{
		"nvd", "redhat", "azure", "debian", "ubuntu", "alpine", "amazon", "oracleoval", "susecvrf", "photon",
		"archlinux", "alma", "rocky", "cblmariner", "rubysec", "phpsecurityadvisories", "nodejssecuritywg",
		"ghsa", "glad", "osv", "k8svulndb",
	}
	for _, sr := range report.Vulnerabilities {
		var pd, lmd string
		if sr.PublishedDate != nil {
			pd = sr.PublishedDate.Format(time.RFC3339)
		}
		if sr.LastModifiedDate != nil {
			lmd = sr.LastModifiedDate.Format(time.RFC3339)
		}

		// Get CVSS scores mapped by vendor
		cvssV3 := GetCvssV3(sr.CVSS)

		// Determine the severity source and CVSS score
		severitySource := string(sr.SeveritySource)
		score, updatedSeveritySource := GetScoreFromCVSS(cvssV3, severitySource, preferredSources)

		if severitySource == "" {
			severitySource = updatedSeveritySource
		}

		// Map CVSS score to severity and compare
		if score != nil {
			mappedSeverity := MapCVSSScoreToSeverity(*score)
			if mappedSeverity != v1alpha1.Severity(sr.Severity) {
				// CVSS score doesn't align with the severity, set score to nil
				score = nil
			}
		}

		vulnerability := v1alpha1.Vulnerability{
			VulnerabilityID:  sr.VulnerabilityID,
			Resource:         sr.PkgName,
			InstalledVersion: sr.InstalledVersion,
			FixedVersion:     sr.FixedVersion,
			PublishedDate:    pd,
			LastModifiedDate: lmd,
			Severity:         v1alpha1.Severity(sr.Severity),
			Title:            sr.Title,
			PrimaryLink:      sr.PrimaryURL,
			Links:            []string{},
			Score:            score,
		}

		if sr.PkgIdentifier.PURL != nil {
			vulnerability.PkgPURL = sr.PkgIdentifier.PURL.String()
		}

		if addFields.Description {
			vulnerability.Description = sr.Description
		}
		if addFields.Links && sr.References != nil {
			vulnerability.Links = sr.References
		}
		if addFields.CVSS && sr.CVSS != nil {
			vulnerability.CVSS = sr.CVSS
		}
		if addFields.Target {
			vulnerability.Target = report.Target
		}
		if addFields.Class {
			vulnerability.Class = string(report.Class)
		}
		if addFields.PackageType {
			vulnerability.PackageType = string(report.Type)
		}
		if addFields.PkgPath {
			vulnerability.PkgPath = sr.PkgPath
		}
		if addFields.SeveritySource {
			vulnerability.SeveritySource = types.SourceID(severitySource)
		}
		if addFields.DataSource && sr.CVSS != nil {
			vulnerability.DataSource = &v1alpha1.DataSource{
				ID:   sr.DataSource.ID,
				Name: sr.DataSource.Name,
				URL:  sr.DataSource.URL,
			}
		}

		vulnerabilities = append(vulnerabilities, vulnerability)
	}

	return vulnerabilities
}

func GetCvssV3(findingCvss types.VendorCVSS) map[string]*CVSS {
	cvssV3 := make(map[string]*CVSS)
	for vendor, cvss := range findingCvss {
		var v3Score *float64
		if cvss.V3Score != 0.0 {
			v3Score = ptr.To[float64](cvss.V3Score)
		}
		cvssV3[string(vendor)] = &CVSS{v3Score}
	}
	return cvssV3
}

// Get CVSS from same source as severity, if not found, follow the order of preferredSources
func GetScoreFromCVSS(cvsss map[string]*CVSS, severitySource string, preferredSources []string) (*float64, string) {
	if score, exists := cvsss[severitySource]; exists && score.V3Score != nil {
		return score.V3Score, severitySource
	}
	for _, source := range preferredSources {
		if score, exists := cvsss[source]; exists && score.V3Score != nil {
			return score.V3Score, source
		}
	}
	for source, score := range cvsss {
		if score.V3Score != nil {
			return score.V3Score, source
		}
	}
	return nil, ""
}

type CVSS struct {
	V3Score *float64 `json:"V3Score,omitempty"`
}

func BuildVulnerabilityReportData(clock ext.Clock, registry v1alpha1.Registry, artifact v1alpha1.Artifact, os v1alpha1.OS, version string, vulnerabilities []v1alpha1.Vulnerability) v1alpha1.VulnerabilityReportData {
	return v1alpha1.VulnerabilityReportData{
		UpdateTimestamp: metav1.NewTime(clock.Now()),
		Scanner: v1alpha1.Scanner{
			Name:    v1alpha1.ScannerNameTrivy,
			Vendor:  "Aqua Security",
			Version: version,
		},
		Registry:        registry,
		Artifact:        artifact,
		OS:              os,
		Summary:         vulnerabilitySummary(vulnerabilities),
		Vulnerabilities: vulnerabilities,
	}
}

func vulnerabilitySummary(vulnerabilities []v1alpha1.Vulnerability) v1alpha1.VulnerabilitySummary {
	var vs v1alpha1.VulnerabilitySummary
	for _, v := range vulnerabilities {
		switch v.Severity {
		case v1alpha1.SeverityCritical:
			vs.CriticalCount++
		case v1alpha1.SeverityHigh:
			vs.HighCount++
		case v1alpha1.SeverityMedium:
			vs.MediumCount++
		case v1alpha1.SeverityLow:
			vs.LowCount++
		default:
			vs.UnknownCount++
		}
	}
	return vs
}

func MapCVSSScoreToSeverity(score float64) v1alpha1.Severity {
	switch {
	case score >= 9.0:
		return v1alpha1.SeverityCritical
	case score >= 7.0:
		return v1alpha1.SeverityHigh
	case score >= 4.0:
		return v1alpha1.SeverityMedium
	case score >= 0.1:
		return v1alpha1.SeverityLow
	default:
		return v1alpha1.SeverityUnknown
	}
}
